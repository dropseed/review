use crate::sources::traits::Comparison;
use crate::trust::matches_pattern;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// A group of related hunks identified by Claude.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HunkGroup {
    pub title: String,
    pub description: String,
    #[serde(rename = "hunkIds")]
    pub hunk_ids: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

/// Stored guide state generated by Claude (grouping + summary).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GuideState {
    pub groups: Vec<HunkGroup>,
    #[serde(rename = "hunkIds")]
    pub hunk_ids: Vec<String>,
    #[serde(rename = "generatedAt")]
    pub generated_at: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
}

/// A line annotation for inline comments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LineAnnotation {
    pub id: String,
    #[serde(rename = "filePath")]
    pub file_path: String,
    #[serde(rename = "lineNumber")]
    pub line_number: u32,
    #[serde(
        rename = "endLineNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub end_line_number: Option<u32>,
    pub side: AnnotationSide,
    pub content: String,
    #[serde(rename = "createdAt")]
    pub created_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AnnotationSide {
    Old,
    New,
    File,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReviewState {
    pub comparison: Comparison,
    pub hunks: HashMap<String, HunkState>,
    #[serde(rename = "trustList")]
    pub trust_list: Vec<String>,
    pub notes: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<LineAnnotation>,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: String,
    /// Version counter for optimistic concurrency control.
    /// Incremented on each save to detect concurrent modifications.
    #[serde(default)]
    pub version: u64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guide: Option<GuideState>,
    /// Total number of hunks in the diff (including unclassified).
    /// Used by `to_summary()` so sidebar progress isn't inflated.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "totalDiffHunks"
    )]
    pub total_diff_hunks: Option<usize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ClassifiedVia {
    Static,
    Ai,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HunkState {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub label: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<HunkStatus>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "classifiedVia"
    )]
    pub classified_via: Option<ClassifiedVia>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum HunkStatus {
    Approved,
    Rejected,
    #[serde(rename = "saved_for_later")]
    SavedForLater,
}

impl ReviewState {
    pub fn new(comparison: Comparison) -> Self {
        let now = chrono_now();
        Self {
            comparison,
            hunks: HashMap::new(),
            trust_list: Vec::new(),
            notes: String::new(),
            annotations: Vec::new(),
            created_at: now.clone(),
            updated_at: now,
            version: 0,
            guide: None,
            total_diff_hunks: None,
        }
    }

    /// Increment version and update timestamp for a save operation
    pub fn prepare_for_save(&mut self) {
        self.version += 1;
        self.updated_at = chrono_now();
    }

    /// Create a summary of this review state
    pub fn to_summary(&self) -> ReviewSummary {
        let total_hunks = self.total_diff_hunks.unwrap_or(self.hunks.len());

        // Single pass over hunks to count all status categories
        let mut approved_hunks = 0usize;
        let mut rejected_hunks = 0usize;
        let mut saved_for_later_hunks = 0usize;
        let mut trusted_hunks = 0usize;

        for h in self.hunks.values() {
            match &h.status {
                Some(HunkStatus::Approved) => approved_hunks += 1,
                Some(HunkStatus::Rejected) => rejected_hunks += 1,
                Some(HunkStatus::SavedForLater) => saved_for_later_hunks += 1,
                None => {
                    // Count hunks with no explicit status but labels matching trust list
                    if h.label.iter().any(|label| {
                        self.trust_list
                            .iter()
                            .any(|pattern| matches_pattern(label, pattern))
                    }) {
                        trusted_hunks += 1;
                    }
                }
            }
        }

        let reviewed_hunks = trusted_hunks + approved_hunks + rejected_hunks;

        let state = if rejected_hunks > 0 {
            Some("changes_requested".to_string())
        } else if reviewed_hunks == total_hunks && total_hunks > 0 {
            Some("approved".to_string())
        } else {
            None
        };

        ReviewSummary {
            comparison: self.comparison.clone(),
            total_hunks,
            trusted_hunks,
            approved_hunks,
            reviewed_hunks,
            rejected_hunks,
            saved_for_later_hunks,
            state,
            updated_at: self.updated_at.clone(),
        }
    }
}

fn chrono_now() -> String {
    // ISO 8601 timestamp without external crate (with milliseconds for JS compatibility)
    use std::time::{SystemTime, UNIX_EPOCH};
    let duration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();
    let secs = duration.as_secs();
    let millis = duration.subsec_millis();

    // Convert to ISO 8601 format (simplified UTC)
    // Days since Unix epoch
    let days = secs / 86400;
    let remaining = secs % 86400;
    let hours = remaining / 3600;
    let minutes = (remaining % 3600) / 60;
    let seconds = remaining % 60;

    // Calculate year, month, day from days since epoch (1970-01-01)
    let mut year = 1970i32;
    let mut remaining_days = days as i32;

    loop {
        let days_in_year = if is_leap_year(year) { 366 } else { 365 };
        if remaining_days < days_in_year {
            break;
        }
        remaining_days -= days_in_year;
        year += 1;
    }

    let days_in_months: [i32; 12] = if is_leap_year(year) {
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    } else {
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    };

    let mut month = 1;
    for days_in_month in &days_in_months {
        if remaining_days < *days_in_month {
            break;
        }
        remaining_days -= *days_in_month;
        month += 1;
    }
    let day = remaining_days + 1;

    format!("{year:04}-{month:02}-{day:02}T{hours:02}:{minutes:02}:{seconds:02}.{millis:03}Z")
}

fn is_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

/// Summary information about a saved review (for listing on start screen)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReviewSummary {
    pub comparison: Comparison,
    #[serde(rename = "totalHunks")]
    pub total_hunks: usize,
    #[serde(rename = "trustedHunks")]
    pub trusted_hunks: usize,
    #[serde(rename = "approvedHunks")]
    pub approved_hunks: usize,
    #[serde(rename = "reviewedHunks")]
    pub reviewed_hunks: usize,
    #[serde(rename = "rejectedHunks")]
    pub rejected_hunks: usize,
    #[serde(rename = "savedForLaterHunks")]
    pub saved_for_later_hunks: usize,
    /// Review state: "approved", "changes_requested", or null (in progress)
    pub state: Option<String>,
    #[serde(rename = "updatedAt")]
    pub updated_at: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    // Pattern matching tests are now in crate::trust::matching::tests
    // These tests verify ReviewState integration with pattern matching

    fn test_comparison() -> Comparison {
        Comparison {
            old: "main".to_string(),
            new: "HEAD".to_string(),
            working_tree: false,
            key: "main..HEAD".to_string(),
            github_pr: None,
        }
    }

    #[test]
    fn test_review_state_new() {
        let comparison = test_comparison();
        let state = ReviewState::new(comparison.clone());

        assert_eq!(state.comparison.key, "main..HEAD");
        assert!(state.hunks.is_empty());
        assert!(state.trust_list.is_empty());
        assert!(state.notes.is_empty());
        assert!(state.annotations.is_empty());
    }

    #[test]
    fn test_review_state_to_summary_empty() {
        let state = ReviewState::new(test_comparison());
        let summary = state.to_summary();

        assert_eq!(summary.total_hunks, 0);
        assert_eq!(summary.reviewed_hunks, 0);
    }

    #[test]
    fn test_review_state_to_summary_with_approved_hunks() {
        let mut state = ReviewState::new(test_comparison());

        // Add an approved hunk
        state.hunks.insert(
            "file.rs:abc123".to_string(),
            HunkState {
                label: vec![],
                reasoning: None,
                status: Some(HunkStatus::Approved),
                classified_via: None,
            },
        );

        // Add a pending hunk
        state.hunks.insert(
            "file.rs:def456".to_string(),
            HunkState {
                label: vec![],
                reasoning: None,
                status: None,
                classified_via: None,
            },
        );

        let summary = state.to_summary();
        assert_eq!(summary.total_hunks, 2);
        assert_eq!(summary.reviewed_hunks, 1);
    }

    #[test]
    fn test_review_state_to_summary_with_trusted_labels() {
        let mut state = ReviewState::new(test_comparison());
        state.trust_list = vec!["imports:*".to_string()];

        // Add a hunk with trusted label (should count as reviewed)
        state.hunks.insert(
            "file.rs:abc123".to_string(),
            HunkState {
                label: vec!["imports:added".to_string()],
                reasoning: None,
                status: None,
                classified_via: None,
            },
        );

        // Add a hunk with non-trusted label
        state.hunks.insert(
            "file.rs:def456".to_string(),
            HunkState {
                label: vec!["code:logic".to_string()],
                reasoning: None,
                status: None,
                classified_via: None,
            },
        );

        let summary = state.to_summary();
        assert_eq!(summary.total_hunks, 2);
        assert_eq!(summary.reviewed_hunks, 1);
    }

    #[test]
    fn test_review_state_to_summary_uses_total_diff_hunks() {
        let mut state = ReviewState::new(test_comparison());
        // Simulate 200 total hunks in the diff but only 2 classified
        state.total_diff_hunks = Some(200);
        state.trust_list = vec!["imports:*".to_string()];

        state.hunks.insert(
            "file.rs:abc123".to_string(),
            HunkState {
                label: vec!["imports:added".to_string()],
                reasoning: None,
                status: None,
                classified_via: None,
            },
        );
        state.hunks.insert(
            "file.rs:def456".to_string(),
            HunkState {
                label: vec!["code:logic".to_string()],
                reasoning: None,
                status: Some(HunkStatus::Approved),
                classified_via: None,
            },
        );

        let summary = state.to_summary();
        // total_hunks should use total_diff_hunks (200), not self.hunks.len() (2)
        assert_eq!(summary.total_hunks, 200);
        assert_eq!(summary.trusted_hunks, 1);
        assert_eq!(summary.approved_hunks, 1);
        assert_eq!(summary.reviewed_hunks, 2);
        // Not all 200 hunks are reviewed, so state should be None
        assert!(summary.state.is_none());
    }

    #[test]
    fn test_review_state_to_summary_falls_back_without_total_diff_hunks() {
        let mut state = ReviewState::new(test_comparison());

        state.hunks.insert(
            "file.rs:abc123".to_string(),
            HunkState {
                label: vec![],
                reasoning: None,
                status: Some(HunkStatus::Approved),
                classified_via: None,
            },
        );

        let summary = state.to_summary();
        assert_eq!(summary.total_hunks, 1);
        assert_eq!(summary.approved_hunks, 1);
        assert_eq!(summary.reviewed_hunks, 1);
        assert_eq!(summary.state, Some("approved".to_string()));
    }

    #[test]
    fn test_chrono_now_format() {
        let timestamp = chrono_now();
        // Should be ISO 8601 format: YYYY-MM-DDTHH:MM:SS.mmmZ
        assert!(timestamp.contains('T'));
        assert!(timestamp.ends_with('Z'));
        // Check rough format with regex pattern
        assert!(timestamp.len() >= 24); // "2024-01-01T00:00:00.000Z"
    }
}
