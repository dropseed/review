use crate::sources::traits::Comparison;
use crate::trust::matches_pattern;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Stored narrative walkthrough generated by Claude.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NarrativeState {
    pub content: String,
    #[serde(rename = "hunkIds")]
    pub hunk_ids: Vec<String>,
    #[serde(rename = "generatedAt")]
    pub generated_at: String,
}

/// A line annotation for inline comments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LineAnnotation {
    pub id: String,
    #[serde(rename = "filePath")]
    pub file_path: String,
    #[serde(rename = "lineNumber")]
    pub line_number: u32,
    #[serde(
        rename = "endLineNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub end_line_number: Option<u32>,
    pub side: AnnotationSide,
    pub content: String,
    #[serde(rename = "createdAt")]
    pub created_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AnnotationSide {
    Old,
    New,
    File,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReviewState {
    pub comparison: Comparison,
    pub hunks: HashMap<String, HunkState>,
    #[serde(rename = "trustList")]
    pub trust_list: Vec<String>,
    pub notes: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<LineAnnotation>,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: String,
    /// Version counter for optimistic concurrency control.
    /// Incremented on each save to detect concurrent modifications.
    #[serde(default)]
    pub version: u64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub narrative: Option<NarrativeState>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ClassifiedVia {
    Static,
    Ai,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HunkState {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub label: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<HunkStatus>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "classifiedVia"
    )]
    pub classified_via: Option<ClassifiedVia>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum HunkStatus {
    Approved,
    Rejected,
}

impl ReviewState {
    pub fn new(comparison: Comparison) -> Self {
        let now = chrono_now();
        Self {
            comparison,
            hunks: HashMap::new(),
            trust_list: Vec::new(),
            notes: String::new(),
            annotations: Vec::new(),
            created_at: now.clone(),
            updated_at: now,
            version: 0,
            narrative: None,
        }
    }

    /// Increment version and update timestamp for a save operation
    pub fn prepare_for_save(&mut self) {
        self.version += 1;
        self.updated_at = chrono_now();
    }

    /// Create a summary of this review state
    pub fn to_summary(&self) -> ReviewSummary {
        let total_hunks = self.hunks.len();
        let rejected_hunks = self
            .hunks
            .values()
            .filter(|h| matches!(h.status, Some(HunkStatus::Rejected)))
            .count();
        // Count hunks that are approved, rejected, or have labels matching trust list
        let reviewed_hunks = self
            .hunks
            .values()
            .filter(|h| {
                // Explicitly approved or rejected
                if h.status.is_some() {
                    return true;
                }
                // Has a label that matches a trust pattern
                if !h.label.is_empty() {
                    for label in &h.label {
                        for pattern in &self.trust_list {
                            if matches_pattern(label, pattern) {
                                return true;
                            }
                        }
                    }
                }
                false
            })
            .count();

        let state = if rejected_hunks > 0 {
            Some("changes_requested".to_string())
        } else if reviewed_hunks == total_hunks && total_hunks > 0 {
            Some("approved".to_string())
        } else {
            None
        };

        ReviewSummary {
            comparison: self.comparison.clone(),
            total_hunks,
            reviewed_hunks,
            rejected_hunks,
            state,
            updated_at: self.updated_at.clone(),
        }
    }
}

fn chrono_now() -> String {
    // ISO 8601 timestamp without external crate (with milliseconds for JS compatibility)
    use std::time::{SystemTime, UNIX_EPOCH};
    let duration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();
    let secs = duration.as_secs();
    let millis = duration.subsec_millis();

    // Convert to ISO 8601 format (simplified UTC)
    // Days since Unix epoch
    let days = secs / 86400;
    let remaining = secs % 86400;
    let hours = remaining / 3600;
    let minutes = (remaining % 3600) / 60;
    let seconds = remaining % 60;

    // Calculate year, month, day from days since epoch (1970-01-01)
    let mut year = 1970i32;
    let mut remaining_days = days as i32;

    loop {
        let days_in_year = if is_leap_year(year) { 366 } else { 365 };
        if remaining_days < days_in_year {
            break;
        }
        remaining_days -= days_in_year;
        year += 1;
    }

    let days_in_months: [i32; 12] = if is_leap_year(year) {
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    } else {
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    };

    let mut month = 1;
    for days_in_month in &days_in_months {
        if remaining_days < *days_in_month {
            break;
        }
        remaining_days -= *days_in_month;
        month += 1;
    }
    let day = remaining_days + 1;

    format!("{year:04}-{month:02}-{day:02}T{hours:02}:{minutes:02}:{seconds:02}.{millis:03}Z")
}

fn is_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

/// Summary information about a saved review (for listing on start screen)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReviewSummary {
    pub comparison: Comparison,
    #[serde(rename = "totalHunks")]
    pub total_hunks: usize,
    #[serde(rename = "reviewedHunks")]
    pub reviewed_hunks: usize,
    #[serde(rename = "rejectedHunks")]
    pub rejected_hunks: usize,
    /// Review state: "approved", "changes_requested", or null (in progress)
    pub state: Option<String>,
    #[serde(rename = "updatedAt")]
    pub updated_at: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    // Pattern matching tests are now in crate::trust::matching::tests
    // These tests verify ReviewState integration with pattern matching

    #[test]
    fn test_review_state_new() {
        let comparison = Comparison {
            old: "main".to_string(),
            new: "HEAD".to_string(),
            working_tree: true,
            staged_only: false,
            key: "main..HEAD+working-tree".to_string(),
            github_pr: None,
        };
        let state = ReviewState::new(comparison.clone());

        assert_eq!(state.comparison.key, "main..HEAD+working-tree");
        assert!(state.hunks.is_empty());
        assert!(state.trust_list.is_empty());
        assert!(state.notes.is_empty());
        assert!(state.annotations.is_empty());
    }

    #[test]
    fn test_review_state_to_summary_empty() {
        let comparison = Comparison {
            old: "main".to_string(),
            new: "HEAD".to_string(),
            working_tree: false,
            staged_only: false,
            key: "main..HEAD".to_string(),
            github_pr: None,
        };
        let state = ReviewState::new(comparison);
        let summary = state.to_summary();

        assert_eq!(summary.total_hunks, 0);
        assert_eq!(summary.reviewed_hunks, 0);
    }

    #[test]
    fn test_review_state_to_summary_with_approved_hunks() {
        let comparison = Comparison {
            old: "main".to_string(),
            new: "HEAD".to_string(),
            working_tree: false,
            staged_only: false,
            key: "main..HEAD".to_string(),
            github_pr: None,
        };
        let mut state = ReviewState::new(comparison);

        // Add an approved hunk
        state.hunks.insert(
            "file.rs:abc123".to_string(),
            HunkState {
                label: vec![],
                reasoning: None,
                status: Some(HunkStatus::Approved),
                classified_via: None,
            },
        );

        // Add a pending hunk
        state.hunks.insert(
            "file.rs:def456".to_string(),
            HunkState {
                label: vec![],
                reasoning: None,
                status: None,
                classified_via: None,
            },
        );

        let summary = state.to_summary();
        assert_eq!(summary.total_hunks, 2);
        assert_eq!(summary.reviewed_hunks, 1);
    }

    #[test]
    fn test_review_state_to_summary_with_trusted_labels() {
        let comparison = Comparison {
            old: "main".to_string(),
            new: "HEAD".to_string(),
            working_tree: false,
            staged_only: false,
            key: "main..HEAD".to_string(),
            github_pr: None,
        };
        let mut state = ReviewState::new(comparison);
        state.trust_list = vec!["imports:*".to_string()];

        // Add a hunk with trusted label (should count as reviewed)
        state.hunks.insert(
            "file.rs:abc123".to_string(),
            HunkState {
                label: vec!["imports:added".to_string()],
                reasoning: None,
                status: None,
                classified_via: None,
            },
        );

        // Add a hunk with non-trusted label
        state.hunks.insert(
            "file.rs:def456".to_string(),
            HunkState {
                label: vec!["code:logic".to_string()],
                reasoning: None,
                status: None,
                classified_via: None,
            },
        );

        let summary = state.to_summary();
        assert_eq!(summary.total_hunks, 2);
        assert_eq!(summary.reviewed_hunks, 1);
    }

    #[test]
    fn test_chrono_now_format() {
        let timestamp = chrono_now();
        // Should be ISO 8601 format: YYYY-MM-DDTHH:MM:SS.mmmZ
        assert!(timestamp.contains('T'));
        assert!(timestamp.ends_with('Z'));
        // Check rough format with regex pattern
        assert!(timestamp.len() >= 24); // "2024-01-01T00:00:00.000Z"
    }
}
